Был реализован интерфейс для создания ультраграфов для систем с дискретным набором команд. Библеотека реализует интерфейс графа предоставляемой библиотекой {\bfseries Boost graph library}. Т.\+о. для программ использующих графы предоставляемый библиотекой boost, можно легко перейти на этот граф, просто подменив их. Также реализовав интерфейс графа boost, появляется возможность использовать множество его графовых алгоритмов.

Для хранения ультраграфа используется следующие 2 структуры\+:


\begin{DoxyEnumerate}
\item {\bfseries Структура связь вершина -\/$>$ ребро.}

``` $\vert$ Ключ $\vert$ Значение $\vert$ $\vert$ -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- $\vert$ $\vert$ id графа $\vert$ Бит инцидетности $\vert$ id вершины $\vert$ id ребра $\vert$ $\vert$ $\vert$ -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ 0..0 $\vert$ Общее кол-\/во вершин $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ id вершины $\vert$ 0..0 $\vert$ Данные вершины $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ id вершины $\vert$ 1..1 $\vert$ Кол-\/во исходящих ребер $\vert$ $\vert$ id графа $\vert$ 1 $\vert$ id вершины $\vert$ 1..1 $\vert$ Кол-\/во входящих ребер $\vert$ ```

Структура хранит вершины и исходящие из них ребра. По этой структуре происходит поиск смежных ребер для указанной вершины. Старший аргумент -\/ идентификатор графа Аргумент {\ttfamily Бит инцидетности} показывает является ли данное ребро входящим или исходящим (0 -\/ исходящее, 1 -\/ входящее), третий аргумент ключа является идентификатор вершины, а младший аргумент -\/ идентификатор смежного ребра. Данные вершины хранятся в значении для записи с ключом, у которого аргумент бит инцидетности рваен 0, аргумент {\ttfamily id вершины} соответствует этой вершине и аргумент {\ttfamily id ребра} равен 0.
\item {\bfseries Структура связь ребро -\/$>$ вершина.}

``` $\vert$ Ключ $\vert$ Значение $\vert$ $\vert$ -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- $\vert$ $\vert$ id графа $\vert$ Бит инцидетности $\vert$ id ребра $\vert$ id вершины $\vert$ $\vert$ $\vert$ -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/--- + -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/--- $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ 0..0 $\vert$ Общее количество ребер $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ id ребра $\vert$ 0..0 $\vert$ Данные ребра $\vert$ $\vert$ id графа $\vert$ 0 $\vert$ id ребра $\vert$ 1..1 $\vert$ Кол-\/во вершин, из кот. выходит ребро $\vert$ $\vert$ id графа $\vert$ 1 $\vert$ id ребра $\vert$ 1..1 $\vert$ Кол-\/во вершин, в кот. входит ребро $\vert$ ```

Структура хранит ребра и вершины, в которые входят эти ребра. По этой структуре происходит поиск смежных вершин для указанного ребра. Аргумент {\ttfamily Бит инцидетности} показывает является ли данное ребро входящим или исходящим (0 -\/ исходящее, 1 -\/ входящее), третий аргумент ключа является идентификатор ребра, а младший аргумент -\/ идентификатор смежной вершины. К ребру можно прикрепить информацию о ребре. Эти данные хранятся в значении для записи с ключом, у которого аргумент бит инцидетности рваен 0, аргумент {\ttfamily id ребра} соответствует этому ребру, и аргумент {\ttfamily id вершины} равен 0.
\end{DoxyEnumerate}

Дескрипторы вершины и ребра ({\ttfamily vertex\+\_\+descriptor}, {\ttfamily edge\+\_\+descriptor}) имеют тип {\ttfamily unsigned long} и являются идентификаторами на соответствующую вершину или ребро в графе. Эти дескрипторы служат для предоставления доступа к вершинам и ребрам графа. Нужно отметить, что {\bfseries при поиске вершины или ребра приоритет имеет тот у кого меньше id}. Таким образом, для взвешенных графов следует формировать идентификатор ребра так, чтобы в старших битах идентификатора ребра находился вес этого ребра. Для формирования такого идентификатора имеется вспомогательный метод {\ttfamily edge\+\_\+descriptor get\+\_\+edge\+\_\+descriptor(id\+\_\+t edge\+\_\+id, weight\+\_\+t weight) const}. Также есть метод для поиска свободного дескриптора ребра с определенным весом ребра {\ttfamily edge\+\_\+descriptor get\+\_\+free\+\_\+edge\+\_\+descriptor(weight\+\_\+t weight) const}.


\begin{DoxyCode}
\{c++\}
#include <iostream>
#include "SpuUltraGraph.h"

using namespace std;
using namespace SPU\_GRAPH;
using namespace boost;

int main()
\{
    // Инициализация графа по умолчанию
    // В этом случае id графа будет равно 0
    SpuUltraGraph graph;

    // Объект черт графа
    SpuUltraGraphTraits traits;
    // Задаю битность. По умолчанию она такая:
    traits.graph\_id\_depth = 3;      // Кол-во бит под id графа
    traits.vertex\_id\_depth = 28;    // Кол-во бит под id вершины
    traits.edge\_id\_depth = 28;      // Кол-во бит под индекс ребра (Индекс ребра НЕ id ребра. id ребра
       состоит из веса и индекса)
    traits.weight\_depth = 4;        // Кол-во бит под вес ребра
    // Указывваю структуры, кот будет использовать наш граф
    GraphStructure vertex\_struct, edge\_struct;
    traits.vertex\_struct = vertex\_struct;
    traits.edge\_struct = edge\_struct;

    // Инициализация графа с id = 5 и указанием черт
    SpuUltraGraph custom\_graph = SpuUltraGraph(5, traits);


    // SpuUltraGraph::vertex\_descriptor - тип идентификатора вершины графа (unsigned long)
    // SpuUltraGraph::edge\_descriptor - тип идентификатора ребра графа (unsigned long)


    // Добавление вершины
    SpuUltraGraph::vertex\_descriptor v1 = graph.add\_vertex();
    // Добаввление вершины с указанием id
    auto v2 = graph.add\_vertex(2);
    // Добаввление вершины с id = 3 и value = 123.123
    auto v3 = graph.add\_vertex(3, 123.123);


    // Добавление ребра
    SpuUltraGraph::edge\_descriptor e1 = graph.add\_edge();
    // Добавление ребра с указанием id
    auto e2 = graph.add\_edge(2);
    // К ребру можно прикрепить данные
    auto e3 = graph.add\_edge(3, data\_t("abc"));
    // Добавление ребра от v1 к v2
    auto e12 = graph.add\_edge(v1, v2);

    // Чтобы добавить ребро с весом, прежде необходимо сформировать edge\_descriptor.
    // Здесь формируется edge\_descriptor у которого вес равен 10 и индекс ребра равен 5.
    // Индекс ребра это не id ребра. Как раз id ребра состоит из веса и индекса.
    SpuUltraGraph::edge\_descriptor e4 = graph.get\_edge\_descriptor(5, 3);
    // Добавление ребра e4 от вершины v2 к v3
    graph.add\_edge(e4, v2, v3);

    // Получение веса ребра из edge\_descriptor
    cout << "Вес ребра e4 = " << graph.get\_weight(e4) << endl;
    // Получение данных вершины. Если вершина не найдена будет исключение
    cout << "Данные вершины v3 = " << (double) graph.get\_vertex\_value(v3) << endl;
    // Получение данных вершины. Если вершина не найдена будет исключение
    cout << "Данные ребра e3 = " << (const char *) graph.get\_edge\_value(e3) << endl;

    // Проверка наличия вершины
    cout << "Наличие вершины v1 = " << graph.has\_vertex(v1) << endl;
    // Проверка наличия ребра
    cout << "Наличие ребра е1 = " << graph.has\_edge(e1) << endl;

    cout << "Кол-во вершин = " << graph.num\_vertices() << endl;
    cout << "Кол-во ребер = " << graph.num\_edges() << endl;
    cout << "Кол-во исходящих ребер у вершины v1 = " << graph.out\_degree(v1) << endl;
    cout << "Кол-во входящих ребер у вершины v1 = " << graph.in\_degree(v1) << endl;
    cout << "Кол-во вершин 'источников' у ребра e12 = " << graph.source\_cnt(e12) << endl;
    cout << "Кол-во вершин 'стоков' у ребра e12 = " << graph.target\_cnt(e12) << endl;


    // Удаление вершины
    graph.remove\_vertex(v1);
    // Удаление всех ребер соединенных с вершиной v2
    graph.clear\_vertex(v2);

    // Удаление ребра
    graph.remove\_edge(e1);
    // Удаление всех ребер от v2 к v3
    graph.remove\_edge(v2, v3);


    v1 = graph.add\_vertex(1);
    graph.add\_edge(10, v1, v2);
    graph.add\_edge(11, v1, v2);
    graph.add\_edge(12, v1, v3);
    graph.add\_edge(13, v2, v1);
    graph.add\_edge(14, v2, v1);
    graph.add\_edge(15, v3, v1);

    cout << "Итерация по всем вершинам: ";
    for (auto v : graph.vertices())
        cout << v <<  ' ';
    cout << endl;

    cout << "Итерация по всем ребрам: ";
    for (auto e : graph.edges())
        cout << e <<  ' ';
    cout << endl;

    cout << "Итерация по исходящим ребрам у вершины v1: ";
    for (auto e : graph.out\_edges(v1))
        cout << e <<  ' ';
    cout << endl;

    cout << "Итерация по входящим ребрам у вершины v1: ";
    for (auto e : graph.in\_edges(v1))
        cout << e <<  ' ';
    cout << endl;

    cout << "Итерация по параллельным ребрам от вершины v1 к v2: ";
    for (auto e : graph.parallel\_edges(v1, v2))
        cout << e <<  ' ';
    cout << endl;

    cout << "Итерация по смежным вершинам для v1: ";
    for (auto v : graph.adjacent\_vertices(v1))
        cout << v <<  ' ';
    cout << endl;

    return 0;
\}
\end{DoxyCode}
 